<html>
    <head>
        <title>6502 like layout ordered by significiance of bits</title>
		<p>
			I have a bit of a problem with SRAM. Word and bitlines cross a lot.
			Shift registers are purely local and seem to be faster if we have a lot of words ( like the 40 character codes in C64, C16).
			There is still the problem with the clock fan out.
			A way to reduce this, to use a tree of multiplexers.
			Clock and write data comes from the root, goes into the leafs, and returns with read data. So there is probably some latency, which is okay for MUL and sprites.
			Do I need latches or flip flops? I really want this double data rate / half clock thing.
			So I need the Original clock and two non overlaping phases alternating on the cycles.
			Then each instruction would still need to remember on which clock it started. Weird. Kinda like register renaming.
			Does each level in the tree need flip flops? Yes, for the clock. Routing is combinatoric logic.
			So basically I have a counter like in a VICII sprite, not a one bit shifter like in the 6502 CPU for the PLA.
		</p>
		<p>
			I want carry look ahead ( because it is cool). I also would like a multiplexer tree. Trees are cool. Trees minimize crossings and vias.
			Latches win in this case because with them we basically move one multiplexer onto the other side.
			Multiplexers are the reason we usually use flip flops. There is still this crossing timing line as in SRAM, but that is it.
			Also we can detangle this: The high speed timing comes from input or output side in between the latch to latch transfer lines.
			So a flip-flop really is the beginning a shift register. It tells us how to manufacture a short sampling at the input and a sharp edge at the output.
			It seems that in this case the clock lines cross the latch to latch transfer. So there is more latency.
			Latches on a bus don't have this transfer and hence less latency.
			Now I really wonder about the MIPS 5-stage pipeline write back shift register. That are a lot of transfers of 32 bit.
		</p>
			Carry look-ahead adds a tree onto the bus. The tree meets in the center. Just no back and forth. Then it is ideal.
			Problem is more that with 8 bit ( minimal viable prototype ), the best implementation has a hight nibble where we calculate with and without carry.
			Then in the second phase there is just a multiplexer. For 16 bit I have much more crossings and would reduce the number of straight lines. This is all so random!
		<p>
		</p>
		<p>
			Thanks to the zero register we only need 5 bits for register names. Renaming happens as data goes through the ALU.
			Ah, the names then need to flow through the pipeline to tell the Load instruction where to load the value into.
			So we have ring of 5 values for this. A 5 stage shifter to select one of this.
			Ah I see, each stage needs access to its value, while there is only one ALU which wants all accesses. So just large shifters are the easiest way to implement this.
		</p>
		<p>
			I don't see that any tree help me with the bus. Or can you imagine the registers sitting in a 2d tree instead of the cross. Neither Arm nor 6502 has a cross.
			A tree with 8 endpoints would have 3 multiplexer nodes. We decode the address on the fly. CMOS would like it.
			So horizontal comming from the ALU. Then vertical. Then horizontal. Then vertical. Then all the load, store, and hold signals from the back.
			I just feel that this needs much more address decoding transistors and it needs a lot of space at the crossing.
		</p>
		<p>
			So the prototype will have no crossings and only ripple adder and 8 bit. The second ALU for MUL, DIV can be stacked onto this.
			Single write back latch can later be exapnded to register renaming.
			Load store blocks the CPU as on 6502 and Z80. Pipeline may come later. Though I am still not sure if it isn't easier to have two write back lines and three load lines over a write back file.
		</p>
        <style>
			.grid-container {
			display: grid;
			grid-template-columns: auto auto auto auto auto auto auto auto;
			grid-gap: 20px;
			}

			.grid-item {
				background-color: rgba(74, 145, 121, 0.8);
  border: 1px solid rgba(0, 0, 0, 0.8);
  padding: 20px;
			}

.Register-File
			{grid-column-start: 1;grid-column-end: 3; }

        </style>
    </head>
    <body>
		<h2>registers File -- ALU</h2>
		<div class="grid-container">
			<div class="grid-item" style="grid-column: 1;"> Pre-decode Register </div><div class="grid-item" > Instruction decoder (PLA) and Interrupts </div><div class="grid-item" > Instruction Register </div>
			<div class="grid-item Register-File"> Gate derived from halved clock ( 6502 uses writeBack register, why cann't I let go from doubel buffer?) </div>
			<div class="grid-item" style="grid-column: 1;"> µ-PC (count down) </div><div class="grid-item"> PC </div> <div class="grid-item">half adder</div><div class="grid-item">Carry</div><div class="grid-item">half adder</div><div class="grid-item"> WriteBack Register </div>
			<div class="grid-item" style="grid-column: 2/6;"> &lt;- WriteBack </div>			
			<div class="grid-item Register-File" > Address decoder </div><div class="grid-item" style="grid-column: 3/6;" > µCode follow up instructions </div>
			<div class="grid-item Register-File"> Latch </div>
			<div class="grid-item Register-File"> Gate </div>
			<div class="grid-item" style="grid-column: 1;"> Data in Register </div><div class="grid-item" > X Register </div><div class="grid-item"> B Register </div> <div class="grid-item">half adder</div><div class="grid-item">Carry</div><div class="grid-item">half adder</div><div class="grid-item"> WriteBack Register </div><div class="grid-item"> Address Register </div>
			<div class="grid-item" style="grid-column: 1;"> Data out Register </div><div class="grid-item" style="grid-column: 2/6;"> &lt;- WriteBack </div>
		</div>
    </body>
</html>