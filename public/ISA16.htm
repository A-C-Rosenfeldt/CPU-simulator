<html>
    <head>
        <title>6502 ISA converted to load-store</title>
        <style>
            table,th,td{
                border: 1px blue solid;
                border-collapse: collapse;
            }
        </style>
    </head>
    <body>
        <h2>registers</h2>
        <table>
            <thead>
                <tr>
                    <th>Lo</th><th>Hi</th><th>long</th>
                </tr>
            </thead>
            <tbody>
                <tr><td>P</td><td>P</td><td>Programm counter</td></tr>
                <tr><td>B</td><td>C</td><td>Accumulator { Buffer:Counter } </td></tr>
                <tr><td>X</td><td>X</td><td>IndeX</td></tr>
                <tr><td>Y</td><td>Y</td><td>another 6 Indices</td></tr>
                <tr><td>S</td><td>S</td><td>Stack Pointer</td></tr>
                <tr><td>F</td><td></td><td>Status Flags: ZNCVID  (oVerflow)</td></tr>
            </tbody>
        </table>

        <h2>Instruction encoding</h2>
        Instructions with two source registers use each bit to select between two possible source for each input of the ALU.  Default accessible register (general purpose) are BCXY.
        Abbreviations: Immediate. Cnd=Condition. Function "Lambda" L. D is direction, 0: towards GeneralPuroposeReg, towards Flags, towards Registers (first wins)
        <table>
            <thead>
                <tr>
                    <th>OP Code</th><th>Function (SubOp)</th><th>source Register(s)</th><th>other source</th><th>Target Register</th><th>Explaination</th>
                </tr>
            </thead>
            <tbody>
				<tr><td>0</td><td>LL0LL</td><td>RRR</td><td>SSS</td><td>TTTT</td><td>Register, Register => Target Register Operation. {TTT0=low byte, 0000=discard result}</td></tr>
				<tr><td>0</td><td>LL1</td><td>VVVVV</td><td>SSS</td><td>TTTT</td><td>Verbatim (signed int), Register => (Register) Operation (&lt;&lt; + -S+V &amp; )</td></tr>
				<tr><td>1</td><td>LDP</td><td>VVVVV</td><td>SSS</td><td>TTTT</td><td>Verbatim (signed int), Register - (Direction)- Memory. P: Persist PointerChange?</td></tr>
                <tr><td>0</td><td></td><td>LL</td><td>TT</td><td>LLLL</td><td>immediate value</td></tr>
                <tr><td>0</td>	<td></td><td>D</td><td>FF</td><td>0</td><td>Set Flag FF={CVDI} to value/Data</td></tr>
                <tr><td>1</td><td>00</td><td></td><td>=RRR</td><td>Cond</td><td>Branch</td></tr>
                <tr><td>1</td><td>01</td><td></td><td>=RRR</td><td>DPSI</td><td>See next table</td></tr>
            </tbody>
        </table>

        <h3>Details</h3>
        <table>
            <thead>
                <tr>
                    <th>P involved</th><th>Stack Involved</th><th>Direction (to GP:0)</th><th>Immediate</th><th>Explanation</th>
                </tr>
            </thead>
            <tbody>
                <tr><td>0</td><td>0</td><td>0</td><td>0</td><td>TSX</td></tr>
                <tr><td>0</td><td>0</td><td>1</td><td>0</td><td>TXS</td></tr>
                <tr><td>0</td><td>1</td><td>0</td><td>0</td><td>PLP</td></tr>
                <tr><td>0</td><td>1</td><td>1</td><td>0</td><td>PHP</td></tr>

                <tr><td>1</td><td>0</td><td>0</td><td>0</td><td>NOP (where else?)</td></tr>
                <tr><td>1</td><td>0</td><td>1</td><td>0</td><td>RTS (shifted from below)</td></tr>
                <tr><td>1</td><td>1</td><td>0</td><td>0</td><td>RTI,(Flags are GP, so this is more specific) </td></tr>
                <tr><td>1</td><td>1</td><td>1</td><td>0</td><td>BRK (where else?)</td></tr>

                <tr><td>1</td><td>0</td><td>0</td><td>1</td><td>JMP</td></tr>
                <tr><td>1</td><td>0</td><td>1</td><td>1</td><td></td></tr>
                <tr><td>1</td><td>1</td><td>0</td><td>1</td><td>JSR </td></tr>
                <tr><td>1</td><td>1</td><td>1</td><td>1</td><td></td></tr>

                <tr><td>0</td><td>0</td><td>0</td><td>1</td><td></td></tr>
                <tr><td>0</td><td>0</td><td>1</td><td>1</td><td></td></tr>
                <tr><td>0</td><td>1</td><td>0</td><td>1</td><td></td></tr>
                <tr><td>0</td><td>1</td><td>1</td><td>1</td><td></td></tr>

            </tbody>
        </table>        
        <h3>8 Register-Register Functions</h3>
        ADC, SBC, SBC with operands swapped, CMP == 111.
        BIT==110, AND, OR, EOR.

Note that for most of these the order of R and S is arbitrary, so can encode two operations.
        <h3> 8 Branch Conditions from 6502</h3>
        <p style="white-space: pre-wrap;">
        = &lt;&gt;
        &gt;= &lt;
        C NC
        V NV
        </p>

        <h2>not ISA, but µ-Architecture taken from 8510</h2>
        <table>
            <thead>
                <tr>
                    <th>Lo</th><th>Hi</th><th>long</th>
                </tr>
            </thead>
            <tbody>
                <tr><td>A</td><td>A</td><td>Address Register</td></tr>
                <tr><td>DI</td><td></td><td>Data in</td></tr>
                <tr><td>DO</td><td></td><td>Data out with Tristate buffer</td></tr>
                <tr><td>PD</td><td></td><td>Pre-decode register</td></tr>
                <tr><td>I</td><td></td><td>Instruction register</td></tr>
                <tr><td>Q</td><td>Q</td><td>Programm counter WriteBack</td></tr>
                <tr><td>W</td><td>W</td><td>ALU WriteBack</td>
                <tr><td>M</td><td></td><td>Micro-Code instruction counter (per cycle, each cycle has 4 (or 8?) phases)</td></tr>
            </tbody>
        </table>
<p>
        The Lo ALU has to inputs connected to XL, B , P  and YL, C, D, S. It has Carry look ahead. AND, OR, EOR, ROR is implemented per bit with some circuitry just as in 8080.

    The high ALU can only do ++ and -- . It uses inverters on odd and even bits and has a flat carry with alternated inverted bits. Inputs are: S,X,Y,P

</p>
    </body>
</html>