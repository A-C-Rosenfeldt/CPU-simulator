<html>
    <head>
        <title>6502 ISA converted to load-store</title>
        <style>
            table,th,td{
                border: 1px blue solid;
                border-collapse: collapse;
            }
        </style>
    </head>
    <body>
        <h1>Back to 8008 or is it 6809?</h1>
        <p>
            It seems that the Motorola 6809 has 5 16 bit registers : X,Y,U,S,DP,(A,B).
            For Arithmetic or memcopy I either need 8 bit or 16 bit. Hence, the register pair A,B is okay.
            And it has microcode for multiplication. Though there is no sign extension version or 16bit factors. 3 bits for MUL. Why no DIV though?
            Or based on ASR? Would rather need an ADDsigned, where the lsb is shifted into carry, and the msb is calculated differently for signed and unsigned.
            I just use little Endian from 8008 and 6502.
        </p>
        <p>
            SRAM even as a register file can be quite compact.
            For rows I want to think of switchable power rails.
            The input into the flip flop is either powered by internal feedback or by the write lines. So there are balanced power lines: On of it is on.
            The output drives the NOT gate to the two read lines. Here again power is supplied from the outside ( address decoder, buffer).
            The ALU bits are aligned to this as is the write back register ( and its short cut ).
            Carry look ahead 4bit x 4blocks disturb this a bit.
            But can do a hybrid. So for the 4 bits I check for carry (1 for next block), 1111 (1 for this), and the rest.
            In the next layer the carry goes over the blocks and I get my flags for a branch.
            Now if I don't mind a little extra storage, I could omit the final counter.
            In the next add this leads to a full adder .. ah overful adder ( two carry bits going through everything).
            Only the writeback short cut may feed its carry into the next add even for logic.
            Still need this extra counter circuitry.
            Don't forget the inverted adders to save one NOT in the carry path!
        </p>
        <p>
            Outside of this the lines may need to be aggregated into a cable. Then I switch it to RAM and ROR ?
            Sticking to 4 NANDs barrel rotation is quite clear: We could address decode all of the 16 rotations in one go.
            Fanout is a bit high and transistor count. So lets divide into two rotation stages with 4 rotations each.
            Rotation is input on rows (3 duplicates), exit on columns, and coupling on the diagonals. A single stage rotation would need 15 dupes total.
        </p>
        <p>
            I got quite interested into RAM. There is this discrete computer with 64kiB made of discrete transistors.
            Now I could reuse the way the register file works. Show the effect of larger fan-out. Of course there would only be one read line.
            IMHO even DRAM ( capacitor is burried and just CU=Q ) with precharge should work.
            I wonder if I could use banks to limit fan out or even have a CMOS address decoder ( router style ).
        </p>
        <p>
        So looking at small code examples, I came to this system design.
        8 registers with nice SRAM and 3 busses to clearly show what is going on.
        I like to reduce the noise due to the write back register. 
        Instead I want to use 4 of the physical registers and register renaming to have 3 read-write registers: Accu, Count, Stackpointer.
        Result of Add can be used as address: Source+Count for example.
        4 registers can only occur as read or write in the instruction.
        </p>
        <p>
            I only show 256 bytes of RAM and ripple carry is fast enough for this.
            Decoded address lines are stored in a pipeline register to give the execution a head start.
            With writeback I could do some ripple in the second phase, though I feel like the carry flag (for branch) will be late then.
            Standalone adders have too much space and current available, so they look ahead.
            I could skew execution, but would need a pipeline register for the decoded read addresses,
            and I will need to wait for carry if the next instruction depends on it.
        </p>
        <p>
            How difficult is register decoding though?
            I need 3 bits for the operation. So StackPointer is assigned the Program-Counter group of instructions.
            There are only two GP-registers: A and C = 1 bit. Then 3 bits for the source=other registers ( 110=PC, 111=SP).
            Load Store to other registers or to memory. Addressing mode [other+C] &lt;-&gt; A . Immediate.
            And then I need 12 bits tic toc for register re-naming. So decode will be slower than ALU anyway ..
            The NZ flags only need a single register because they are always written as a whole or read.
            Only carray needs to be double for ROR and ADC.
        </p>
        <p>
            Best I can do is not overshot a branch instruction. So I use an 8 bit ripple counter for the PC.
            I show the decoding on screen just like the register file.
            From this it should be clear that instruction fetch does indeed cost a cylce ( no decoded pipeline register, but a whole whopping 8 bits and pages ).
            I check for 001 in "other register" while memory reads out the immediate and PC increments.
            If 001, I veto the read and instead direct any waiting load store .
            Now I can see how a 2 cycle decode circuit would want data memory access in every instruction.
            I guess I'd rather go with a pipeline here.
        </p>
        <h1>sources need to be decoded easily</h1>
        We have 2x3 bits for the sources. They are 5 general purpose registers, the programPointer, immediate value ( data register after the decoding phase ).
        One of the sources is called source, the other target because we also write back to it.
        We have one encoding slot free. It is fast to give the row slot to one of the general purpose registers two slots "accumulator" A on row so that we have 3 bits for the opcode.
        The column slot ( source ) is given to another GPregister "stackPointer" S. When we access the StackPointer there, the instruction bits mean Load/Store and Byte/Word instead (with ++ and -- for the stack).
        Two GPregisters are SourceIndex(X) and DestinationIndex(Y). They support COPY (TXA) and one supports Load and the other Store. On themselves, COPY becomes ++ and --.
        In combination with A, in the second row, they do store and load in combination with ++ and -- ( recognize the byte/word flag).
        On von Neumann architecture we have a slot to write back the new address, while the instruction fetch has to wait on data memory access.
        With (I + X) addressing we can peek data into register B (I+S also).
        ProgramPointer + immediate give us relative branches. We have 8 of those. So it seems that I need both, immediate and ProgramPointer on source and target.
        ProgramPointer can be copied into some registers, but we do not need all. It makes no sense to have so many ProgrammPointer related instructions even with RTI and BRK,
        but then again, all on the row are redefined as unary operation on the column operand.
        <h1> If I need more than 4 registers, I cannot keep registers and operations orthogonal </h1>
        <p>
            After we counted all operations and removed all dupes, we now do fancy stuff.
            Aparently, we could either do 16 bit RISC, or 8 bit and complicated encoding. Simple 8 bit don't cut it for the canon of algorithms.
            I need 4 registers for those. One as a StackPointer, one as a ProgrammPointer, and I reserve one number for the explict access to the ALU flags ( but not that interrupt flag or BCD or stuff).
            So 7 address. Registers can only see 4 other register. This is a bit hard on encoding because of carry ripple.
            If the encoded target is too far away, the register-msb is inverted and also the opcode msb ( bit 2 ) to give us 8 opcodes :
            OR=++, AND=--, COPY=load immediate, xor=clea, add=shl, asr, not, sub=neg.          
        </p>
        <p>
            Load and Store need to access all registers. Copy operation shows that both ( or three ) address register should be used with all other registers ( itself for indirect ).
            In column 7 is Store and in row 7 is Load. They don't get mapped to via xor ( so even more complicated decoding). One bit for the address register and one for byte vs word.
        </p>
        <p> Flags to ProgramPointer needs 8 conditions at least. ProgramPointer on itselft is branch always and two bits. Program Pointer to flags is ? Flag to flag is Set and Clear and needs 8 bits. </p>
        <p> register to Program Pointer has two bits: clear interrupt? set interrupt? (why do I even care so much about interrupt)? It is like NOP. I would rather have a prefix for jump to deal with this.</p>
        <p> Flags to register is only one COPY instruction. So I guess I have to place ADC, SBC, ROR and ROL here </p>
        <p> register to flag can mean CMP and Test with one other value register ( similar to address register ) </p>
        <p> Basically, only flag-> flag and flag -> ProgramPointer make sense. So there is a real register, which is accessed for most opcodes and all bits >3.
            The flag register still infects its friend registers with ADC,SBC,ROR,ROL </p>
        <p>
            If we encode two register in 6 bits, how do I suppress interaction between different types of registers?
            Similar to register4 copy, we cannot encode registers verbatim. Some decoding is needed.
            Move corners towards the diagonal.
            Sum of opcode and both registerIds is the operation.
            X and Y address registers ( or SI, DI ) want access to all values, thus they have the matrix at full width.
            Due to symmetry two registers can receive from everwhere.
            Oh, nonsense. Due wrap around the locality leads to two para diagonals which are empty.            
        </p>
        <p> 4 neighbors of 8 -- Worst case are two COPY instructions or 4 to avoid trash.
            Sure we don't have enough encoding space. It is the other way around. Each register sees itself and its neighbors.
            So to reach the other side of the globe you have to go 4 steps to either side.
            8 registers in total like in 8080 -- but this time with 16 bit -- sound too much.
            We have 4 general purpose for our algorithms and snippets. ProgramPointer, flags, and StackPointer just add 3 more.
            With 7 register we have the advantage that there is no register on the exact oposite side. We only need 3 copy to go over.
        </p>
        <pre style="white-space: pre-wrap;">
            xxxoooxx
            xxxxooox
            xxxxxooo
            oxxxxxoo
            ooxxxxxo
            oooxxxxx
            xoooxxxx
            xxoooxxx
        </pre>
        <p>
        Some register have easy move to program counter. They need to be stored and loaded from memory. I want to park interrupt instructions here.
        Some register hold address. They need add and count. 2 bit for operation are just right. All value registers should be available.
        Some registers count.
        Some function as streaming buffers for DIV and MUL: they ROR
        The Accumulator is the real deal and does everything, but this would break the symmetry.        
        Some hold values to compare or test to.
        Some are flags, which can be exchanged with the real flags. And XOR. Flag to ProgramPointer means branch. We need more bits to describe all combinations.
        *wrap around*
        </p>
        <p>
            3 bits for source and target.
            If source-target away more then 4, xor the target and make it a move because target address generation is delayed.
            Swap the bytes, only move one of them => 4 combos. Load Store using one of the address registers.
            We can have 4 binary operations.
            That does not work. We need 3 bits for source, 2 for target, and 3 for operation ( see list below ).
            Even flag to and from ProgramPointer needs 3 bits.
            Register to ProgramPointer just needs two bits to say what to do with the interrupflag. (ProgramPointer can be copied onto itself)
            Address register work with all other Targets. They only need two bits: read/write, load/store .
        </p>
        <p>
            Use "low resolution" of 2 bit for source and target to calculate distance and to keep all combos for the address registers. If too far way: Xor target.
        </p>
        <h1> Two register format is the only sane encoding in 8 bit </h1>
        Encodings with more than 8 bit can include immediate values.
        Immediate encourage self modifying code which I don't want because historically 8 bit code often ran from ROM.
        Immediate memory addresses lead to akwarded memory management.
        We have 4 general purpose registers (0123 or ABXY or ABST) to keep the canon of inner loops in them: DIV, MUL, shift, mirror, bitscan, block-Operations, Fibonacci Sequence.
        With only 4 register, it makes sense to have CMP and TEST.
        Though we need a 5th register to keep our context "Stack Pointer".
        We place it on the other half of the internal bus, together with PP, Data, Address (write), WriteBack (read), Flags.
        <h2> 7 bit. Two register (4), 8 instructions (3) </h2> 
        Operations on consecutive lines have a lot in common.
        <table>
            <thead>
                <tr><th>Operation</th><th>source=target</th></tr>
            </thead>
            <tbody>
                <tr><td>ADC</td><td>ROL (natural)</td></tr>
                <tr><td>SBC</td><td>NEG</td></tr>
                <tr><td>CMP</td><td>ROR ( close to ROL) </td></tr>
                <tr><td>TEST</td><td>ASR ( close to ROR)</td></tr>
                <tr><td>AND</td><td>sign extend</td></tr>
                <tr><td>OR</td><td>INC ( OR goes to 1)</td></tr>
                <tr><td>XOR</td><td>NOT</td></tr>
                <tr><td>32 bit ROR by one byte</td><td>swap bytes</td></tr>
            </tbody>
            <p> Although AND and OR may profit from 3 register format, it is not justified to have those and TEST.
                I prefer TEST. 3 register encoding adds complexity.
                3 register encoding needs to deduce an operation bit from the operands, which feel weird.
            </p>
        </table>
        
        <h2> 6 bits: Address </h2>
        <p>
            Two register and the load vs store bit and byte(sign extended)/word bit.
            For store and both registers the same => makes no sense.
            Those instructions are redefined as: Load Immediate
        </p>

        <h2> 6 bit: Copy</h2>
        <p>
        I need that scratchpad register to push context to. Thus I guess I need 5 register copy.
        At least within copy all regs are the same. Counting tells me that I can have 6 registers! But I hate copy .. it does nothing.
        </p>
        <p>
            If target register > 4 then this is "Jump and Interrupt instead"
            If source register > 4 then this is "Branch and Flag" instead.
            if source = target then DEC  (for counter in MUL, DIV, and memory block operations, or even an address in a stack).
            Maybe source register = 5 could mean INC.
            Or we could promote register 4 to an address register. Always word, but soure=5 means Store[4] and target=5 means Load[4]
        </p>

        <h2>5 bit: Program flow</h2>
        <h3> 4 bit &gt; Jump and interrupts </h3>
        <ul>
            <li> jump | Jump and set interrupt flag | set  (3 states left over from copy)</li>
            <li> Enter or leave?</li>
        </ul>
        <p> Leave jump load register 1 to ProgramPointer while enter stores the programPointer in 1 and loads 0 in the program pointer. </p>        

        <h3> 4 bit &gt; Branch and flags </h3>
        2 bits for the flag: zero, negative, carry, overflow <br/>
        1 bit for the value. <br/>
        1 bit for read (branch) or write (set|clear).<br/>

        <p>Maybe we use the triState to have:</p>
        <ul>
            <li> [ negative | zero | positive ] as cases and mark the case where we want to jump => 3 bits and includes branch always</li>
            <li> We choose carry xor overflow and jump on value => 2 bits </li>
        </ul>
        <p>Only 3 combinations of flags can be set. => 5 free encodings</p>
        <h2> Mindless filling up the residual encodings. </h2>
        <p>
            Branch always. Load/Store Flags to register 2.
        </p>    

        <h1> OLD </h1> <p> Register encoding formate is King </p>
        <h2> Instructions I got to know a new ISA which is more based on instructons than register</h2>
        <h3> 6 bits: Address </h3>
        <p>
            Two register and the load vs store bit and byte/word bit.
            For store and both registers the same => makes no sense.
            Those isntructions are redefined as:
            Load Immediate8 into low byte,
            Load HiByte immediate8.
        </p>

        <h3> 6 bits Two register format </h3>
        <p>
            Source can be constant: 1bit. 4 bits for registers. One bit to choose between ADC and XOR.
            AND with itself is SHL. XOR with itself is clear (but maybe redefined () I want to keep my decoding simple).
        <p>
            Constants: sign, exponent: +2 +1 -1 -2
            XOR with -1 is NNOT.  The other three values are defined as these instructions:
            SAR, ROR through carry, ROL through carry ( to keep them close to SHL).
        <h3> 6 bits : Source[] => Target three register format: Logical AND and OR and COPY. </h3>
        <p>       
        if ( source0 &gt; source1 ) AND   -- just think of a matrix with main diagonal .. nothing cyclic <br/>
        if ( source0 &lt; source1 ) OR  <br/>
        else COPY <br/>
        </p><p>COPY onto itself means "swap bytes". </p>

        <h3> 5 bit &lt; : SBC use 2 source registers and then one of them is the target</h3>
        <p> The target is either 111, or 110 meaning indriectly source0 or source1.
            101 means: Discard result == CMP.
            Other values mean: Branch</p>
            <p>
                If both source are the same, target says which one to replace with the immediate value.
                I would rather have 3 bits for the source.
                Jump and Sub combined already use 6 bits, but
                we would still have to encode [const?,const?,target] into 2 bits.
                I cannot go down to three register bacause MUL, DIV, block COPY, SCAN etc. need 4 registers.
            </p>
        <h3> 5 bit &gt; Jump and flags </h3>
        3 bits for the flag: zero, negative, carry, overflow, const 1== interrupt <br/>
        1 bit for the value. <br/>
        1 bit for read (branch) or write.<br/>
        <p> On read the interrupt flag is always 0 for branch always with value=0.
        No jump instead means to store the ProgramPointer is swapped with register.0 (think RCA 1802).
        STI and CLI are delayed by one cycle to allow RTI macro and BRK macro.
        </p>
            Missing atm: atomic RTI, jump absolute should use two registers.
        </p>
        <h1>ALU</h1>
        The ALU receives two operands and prepares everything for the central carry propagation.
        Only two operations on the carry make sense: Identity, inversion. Otherwise we could have already sent the signal.
        So both of these gates read the input, but only one is powererd up by the preparation cirtuit.
        Indentity is implemented as two inversions. When you try to optimize for example for equal lenght signal path,
        you end up at a carry look ahead cirtuit ( bottom up ).
        <h1>Old</h1>
        <h3> Source ( may be a const) => Target two register format </h3>        
        <h4> Some only affect the flags</h4>
        Exclusive OR: XOR, Test (target is really just a source), the constant is sign extended: NOT (do not count, is in constant) <br/>
        Subtract: SUB, SBC, CMP (target is really just a source), NEG ( SUB with commuted operands)

        <h4> Add </h4>
        Add, Adc ( similar to sbc above)
        <p>So 8 variants + the const? flag => 4 bits . And then both registers. Uh. </p>
        <h4> Jump </h4>
        Relative const or absolute register. Condition (the 3 of 6502 and for 16 bit encoding all other combinations also)).
        <p> 4 bit + register does not sound too bad. The 8 bit encoding better uses immediate values </p>
        <h4> Address </h4>
        Address Register and Value Register. Load vs Store. PostIncrement? ( maybe switchable in direction Flag?)
        <p>One could think that RISC does not need too much memory acces, but still we seem to need a quarter of the endoding space.</p>
        <h4> shift </h4>
        Two registers for 16bit encoding, but only one for 8 bit encoding.

        <h1> Register centric version </h1>
        <h2>registers</h2>
        <table>
            <thead>
                <tr>
                    <th>Lo</th><th>Hi</th><th>long</th>
                </tr>
            </thead>
            <tbody>
                <tr><td>P</td><td>P</td><td>Programm counter</td></tr>
                <tr><td>B</td><td>C</td><td>Accumulator { Buffer:Counter } </td></tr>
                <tr><td>X</td><td>X</td><td>IndeX</td></tr>
                <tr><td>Y</td><td>Y</td><td>another Index</td></tr>
                <tr><td>S</td><td>S</td><td>Stack Pointer</td></tr>
                <tr><td>F</td><td></td><td>Status Flags: ZNCVID  (oVerflow)</td></tr>
            </tbody>
        </table>

        <h1>Instruction encoding</h1>
        Instructions with two source registers use each bit to select between two possible source for each input of the ALU.  Default accessible register (general purpose) are BCXY.
        Abbreviations: Immediate. Cnd=Condition. Function "Lambda" L. D is direction, 0: towards GeneralPuroposeReg, towards Flags, towards Registers (first wins)
        <table>
            <thead>
                <tr>
                    <th>OP Code</th><th>Function (SubOp)</th><th>source Register(s)</th><th>Direction</th><th>Target Register</th><th>Immediate</th><th>Explaination</th>
                </tr>
            </thead>
            <tbody>
                <tr><td>1</td><td>LLL&lt;110</td><td>R={B C} R={X Y}</td><td></td><td>TT</td><td></td><td>Register, Register => (Register) Operation. 8:16 bit limitation is motivated by relative addressing</td></tr>
                <tr><td>1110</td><td></td><td>RR</td><td></td><td>LL</td><td></td><td>CMP, BIT , low byte only .. </td></tr>
                <tr><td>1111</td><td></td><td>L</td><td>D</td><td>TT</td><td></td><td>Rotation through carry in Direction, AS</td></tr>
                <tr><td>01</td><td>LL</td><td>R</td><td>D</td><td>T</td><td>0</td><td>Pointer Operation. R={X,Y}, T={B,BC}  </td></tr>
                <tr><td>01</td><td>LL</td><td>R</td><td>D</td><td>T</td><td>1</td><td>Index Operation</td></tr>
                <tr><td>001</td><td></td><td></td><td>RR</td><td>TT</td><td>0</td><td>Copy to register</td></tr>
                <tr><td>001</td><td></td><td></td><td>LL</td><td>TT</td><td>1</td><td>immediate value</td></tr>
                <tr><td>0001</td><td></td><td></td><td>D=1</td><td>FF</td><td>V</td><td>Set Flag FF={CVDI} to Value</td></tr>
                <tr><td>0001</td><td></td><td></td><td>D=0</td><td>FF</td><td>V</td><td>Get Flag aka If FFlag==Voume? Branch!</td></tr>
                <tr><td>0000</td><td></td><td></td><td>D</td><td>PS</td><td>I</td><td>See next table</td></tr>
            </tbody>
        </table>
        <h2> trying to unify S with X and Y</h2>
        <table>
            <thead>
                <tr>
                    <th>OP Code</th><th>Function (SubOp)</th><th>source Register(s)</th><th>Direction</th><th>Function2</th><th>Target Register</th><th>Explaination</th>
                </tr>
            </thead>
            <tbody>
                <tr><td>1</td><td>LLL&lt;110</td><td>R={B C} R={X Y}</td><td></td><td>TT</td><td></td><td>Register, Register => (Register) Operation. 8:16 bit limitation is motivated by relative addressing</td></tr>
                <tr><td>1010     </td><td></td><td></td> <td></td><td>LL=++ -- not neg</td> <td>TT</td><td>Typical in place operations. +=2 and -=2 maybe also</td></tr>
                <tr><td>1000</td><td></td><td></td><td>D</td><td>L</td><td>TT</td><td>Rotation through carry in Direction, Arithmetic Shift</td></tr>

                <tr><td>0111</td><td></td><td>R={B C} R={X Y}</td><td></td><td>LL</td><td></td><td>CMP, BIT , low byte only ... Uh, no 9bit sprite collision for C64? </td></tr>
                <tr style="border-bottom: 2px solid black;">    </tr><td>0110</td><td> </td><td>RR   </td><td></td><td></td><td>TT</td><td>Copy to register (RR==TT?immediate) </td></tr>
                

                
                <tr><td>0101=Immediate   </td> <td></td> <td></td><td></td> <td>LLL</td> <td>T=B,Y</td> <td>L like Opcode 1 & CMP & BIT</td></tr>
                <tr><td>0100=Displacement</td> <td></td><td>R=X,Y</td> <td>D</td><td>8bit|16bit displacement</td> <td>T=B|other index</td><td></td></tr>
                <tr><td>0011=Stream      </td> <td></td><td>R=X,Y</td> <td>D</td><td>++ --</td> <td>T=B|other index</td><td></td></tr>
                <tr><td>0010=Stack       </td> <td></td><td>R=S  </td> <td>D</td><td>++ --</td> <td>TT={B,X,PStatus,PCounter}</td><td> wrong combination of D and ++ --  changes  JSR to BRK and RTS to RTI </td></tr>
                <tr><td>0001=Absolute    </td> <td></td> <td>8bit|16bit address</td>  <td>D</td><td></td><td>TT = B C X </td></tr>
                <tr><td>0001=Absolute    </td> <td></td><td>8bit|16bit address</td><td>Indirect? Swap Y and PC?</td><td></td> <td>TT = PC</td><td>JMP ... indirect is 6502.  Swap Y and PC is the MIPS way</td></tr>
                
                <tr style="border-top: 2px solid black;"><td>0000</td><td></td><td></td><td>D=1</td><td>FF</td><td>V</td><td>Set Flag FF={CVDI} to Value</td></tr>
                <tr><td>0000</td><td></td><td></td><td>D=0</td><td>FF</td><td>V</td><td>Get Flag aka If FFlag==Value? Branch!</td></tr>
            </tbody>

        </table>     
        
        <h3>Details about stack based Instructions: Wrong combination of ++ and D is reversed and second function activated</h3>
        <table>
            <thead>
                <tr>
                    <th>Original function</th><th>reversed</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <tr><td>JSR</td><td>BRK</td></tr>
                    <tr><td>RTS</td><td>RTI</td></tr>
                    <tr><td>PHX</td><td>TXS</td></tr>
                    <tr><td>PLX</td><td>TSX</td></tr>                    
                </tr>
            </tbody>
        </table> 

        <h3> trying to unify S with X and Y (old version)</h3>
        <table>
            <thead>
                <tr>
                    <th>OP Code</th><th>Function (SubOp)</th><th>source Register(s)</th><th>Direction</th><th>Target Register</th><th>Immediate</th><th>Explaination</th>
                </tr>
            </thead>
            <tbody>
                <tr><td>1</td><td>LLL&lt;110</td><td>R={B C} R={X Y}</td><td></td><td>TT</td><td></td><td>Register, Register => (Register) Operation. 8:16 bit limitation is motivated by relative addressing</td></tr>
                <tr ><td>1110</td><td></td><td>RR</td><td></td><td>LL</td><td></td><td>CMP, BIT , low byte only .. </td></tr>
                <tr style="border-bottom: 2px solid black;"><td>1111</td><td></td><td>L</td><td>D</td><td>TT</td><td></td><td>Rotation through carry in Direction, AS</td></tr>
                <tr><td>0</td><td>LL=010..100 </td><td>R=X,Y</td><td>D</td><td>T</td><td></td><td>Pointer Operation, reverse stack. R={X,Y}, T={B,BC}. {LL=010 & T=1 ? TSX }  </td></tr>
                <tr><td>0</td><td>LL={101=BRK-RTI,110=JSR-RTS} for progamm counter, LL={R=S instead of Y} for B</td><td>R=Y,S  </td><td>D</td><td>T</td><td></td><td>Pointer Operation. stack , T={B ,Processor status,Program-Counter}  </td></tr>
                <tr><td>0</td><td>LL=111A </td><td>R=X,Y   </td><td>D</td><td>T</td><td></td><td>Index Operation with immediate / Addressing mode {I16, I16+Y8, X16+I8, Y16+I8</td></tr>

                <tr style="border-top: 2px solid black;" ><td>0001</td><td> </td><td>RR   </td><td></td><td>TT</td><td></td><td>Copy to register (RR==TT?immediate) </td></tr>
                <tr><td>0000</td><td></td><td></td><td>D=1</td><td>FF</td><td>V</td><td>Set Flag FF={CVDI} to Value</td></tr>
                <tr><td>0000</td><td></td><td></td><td>D=0</td><td>FF</td><td>V</td><td>Get Flag aka If FFlag==Voume? Branch!</td></tr>
            </tbody>

        </table>      
        Okay, I can see why MIPS did away with the stack. So I could -- like 6502 and MIPS -- have DEX extra and JumpAndLink via register.
        Even with inner loops, immediate is just too nice to not have all reg-reg also with immediate.
        That would mean as many immediate as reg reg because the format is the same ( reg reg as two separate input groups).  
        <h3>Details</h3>
        <table>
            <thead>
                <tr>
                    <th>P involved</th><th>Stack Involved</th><th>Direction (to GP:0)</th><th>Immediate</th><th>Explanation</th>
                </tr>
            </thead>
            <tbody>
                <tr><td>0</td><td>0</td><td>0</td><td>0</td><td>TSX</td></tr>
                <tr><td>0</td><td>0</td><td>1</td><td>0</td><td>TXS</td></tr>
                <tr><td>0</td><td>1</td><td>0</td><td>0</td><td>PLP</td></tr>
                <tr><td>0</td><td>1</td><td>1</td><td>0</td><td>PHP</td></tr>

                <tr><td>1</td><td>0</td><td>0</td><td>0</td><td>NOP (where else?)</td></tr>
                <tr><td>1</td><td>0</td><td>1</td><td>0</td><td>RTS (shifted from below)</td></tr>
                <tr><td>1</td><td>1</td><td>0</td><td>0</td><td>RTI,(Flags are GP, so this is more specific) </td></tr>
                <tr><td>1</td><td>1</td><td>1</td><td>0</td><td>BRK (where else?)</td></tr>

                <tr><td>1</td><td>0</td><td>0</td><td>1</td><td>JMP</td></tr>
                <tr><td>1</td><td>0</td><td>1</td><td>1</td><td></td></tr>
                <tr><td>1</td><td>1</td><td>0</td><td>1</td><td>JSR </td></tr>
                <tr><td>1</td><td>1</td><td>1</td><td>1</td><td></td></tr>

                <tr><td>0</td><td>0</td><td>0</td><td>1</td><td></td></tr>
                <tr><td>0</td><td>0</td><td>1</td><td>1</td><td></td></tr>
                <tr><td>0</td><td>1</td><td>0</td><td>1</td><td>?PHA</td></tr>
                <tr><td>0</td><td>1</td><td>1</td><td>1</td><td>?PLA</td></tr>

            </tbody>
        </table>        
        <h3>8 Register-Register Functions</h3>
        ADC, SBC, SBC with operands swapped, CMP == 111.
        BIT==110, AND, OR, EOR.
        <h3> Pointer </h3>
        <table>
            <thead>
                <tr>
                    <th>LL</th><th>Explanation</th>
                </tr>
            </thead>
            <tbody>
                <tr><td> 00 </td><td> plain </td></tr>
                <tr><td> 01 </td><td> ++/-- only, no actual data access (T is not used, Direction is used )</td></tr>
                <tr><td> 10 </td><td> ++/-- </td></tr>
                <tr><td> 11 </td><td> ++/-- X becomes S for PHA and PLA, while Y Stack becomes reversed for memcopy</td></tr>
            </tbody>
        </table>

        <h3>Index</h3>
        <table>
            <thead>
                <tr>
                    <th>LL</th><th>Addressing mode</th>
                </tr>
            </thead>
            <tbody>
                <tr><td> 00 </td><td> I16 </td></tr>
                <tr><td> 01 </td><td> I16 + RL  ( register Lo byte ) </td></tr>
                <tr><td> 10 </td><td> I16 + RH </td></tr>
                <tr><td> 11 </td><td> I8 + R  ( or better: R + I8)</td></tr>
            </tbody>
        </table>        

        <h3> Copy to register</h3>
        <table>
            <thead>
                <tr>
                    <th>RR==TT</th><th>Function</th>
                </tr>
            </thead>
            <tbody>
                <tr><td> 00=B </td><td> NOT </td></tr>
                <tr><td> 01=C </td><td> DEC </td></tr>
                <tr><td> 10=X </td><td> NOT </td></tr>
                <tr><td> 11=Y </td><td> NEG </td></tr>
            </tbody>
        </table>        

        <h3> Immediate Value</h3>
        <table>
            <thead>
                <tr>
                    <th>LL</th><th>Function</th>
                </tr>
            </thead>
            <tbody>
                <tr><td> 00 </td><td> Load </td></tr>
                <tr><td> 01 </td><td> ADC </td></tr>
                <tr><td> 10 </td><td> AND </td></tr>
                <tr><td> 11 </td><td> BIT for B and CMP for C </td></tr>
            </tbody>
        </table>

        <h3> 8 Branch Conditions from 6502</h3>
        <p style="white-space: pre-wrap;">
        = &lt;&gt;
        &gt;= &lt;
        C NC
        V NV
        </p>

        <h2>not ISA, but µ-Architecture taken from 8510</h2>
        <table>
            <thead>
                <tr>
                    <th>Lo</th><th>Hi</th><th>long</th>
                </tr>
            </thead>
            <tbody>
                <tr><td>A</td><td>A</td><td>Address Register</td></tr>
                <tr><td>DI</td><td></td><td>Data in</td></tr>
                <tr><td>DO</td><td></td><td>Data out with Tristate buffer</td></tr>
                <tr><td>PD</td><td></td><td>Pre-decode register</td></tr>
                <tr><td>I</td><td></td><td>Instruction register</td></tr>
                <tr><td>Q</td><td>Q</td><td>Programm counter WriteBack</td></tr>
                <tr><td>W</td><td>W</td><td>ALU WriteBack</td>
                <tr><td>M</td><td></td><td>Micro-Code instruction counter (per cycle, each cycle has 4 (or 8?) phases)</td></tr>
            </tbody>
        </table>
<p>
        The Lo ALU has to inputs connected to XL, B , P  and YL, C, D, S. It has Carry look ahead. AND, OR, EOR, ROR is implemented per bit with some circuitry just as in 8080.

    The high ALU can only do ++ and -- . It uses inverters on odd and even bits and has a flat carry with alternated inverted bits. Inputs are: S,X,Y,P

</p>
<a href="ISA16.htm">16 bit words</a>
<a href="Layout.htm">16 bit words</a>
    </body>
</html>