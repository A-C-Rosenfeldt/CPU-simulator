<html>
    <head>
        <title>6502 ISA converted to load-store</title>
        <style>
            table,th,td{
                border: 1px blue solid;
                border-collapse: collapse;
            }
        </style>
    </head>
    <body>
        <h1> Two register format is the only sane encoding in 8 bit </h1>
        Encodings with more than 8 bit can include immediate values.
        Immediate encourage self modifying code which I don't want because historically 8 bit code often ran from ROM.
        Immediate memory addresses lead to akwarded memory management.
        We have 4 general purpose registers to keep the canon of inner loops in them: DIV, MUL, shift, mirror, bitscan, block-Operations.
        Wiht only 4 register, it makes sense to have CMP and TEST.
        <h2> 7 bit. Two register (4), 8 instructions (3) </h2> 
        Operations on consecutive lines have a lot in common.
        <table>
            <thead>
                <tr><th>Operation</th><th>source=target</th></tr>
            </thead>
            <tbody>
                <tr><td>ADC</td><td>ROL (natural)</td></tr>
                <tr><td>SBC</td><td>NEG</td></tr>
                <tr><td>CMP</td><td>ROR ( close to ROL) </td></tr>
                <tr><td>TEST</td><td>ASR ( close to ROR)</td></tr>
                <tr><td>AND</td><td>DEC ( AND goes to 0)</td></tr>
                <tr><td>OR</td><td>INC ( OR goes to 1)</td></tr>
                <tr><td>XOR</td><td>NOT</td></tr>
                <tr><td>CPY</td><td>swap bytes</td></tr>
            </tbody>
            <p> Although AND and OR may profit from 3 register format, it is not justified to have those and TEST.
                I prefer TEST. 3 register encoding adds complexity.
                3 register encoding needs to deduce an operation bit from the operands, which feel weird.
            </p>
        </table>
        
        <h2> 6 bits: Address </h2>
        <p>
            Two register and the load vs store bit and byte(sign extended)/word bit.
            For store and both registers the same => makes no sense.
            Those isntructions are redefined as: Load Immediate
        </p>

        <h2>5 bit: Program flow</h2>
        <h3> 4 bit &gt; Branch and flags </h3>
        2 bits for the flag: zero, negative, carry, overflow <br/>
        1 bit for the value. <br/>
        1 bit for read (branch) or write (set|clear).<br/>

        <h3> 4 bit &gt; Jump and interrupts </h3>
        <ul>
            <li> interrupt flag set ?</li>
            <li> interrupt flag cleared ?</li>
            <li> jump (copy register 0 to ProgramPointer)?</li>
            <li> programPointer move to register 1? </li>
        </ul>

        <h2> Mindless filling up the residual encodings. </h2>
        <p>
            Branch always. Load/Store Flags to register 2.
        </p>    

        <h1> OLD </h1> <p> Register encoding formate is King </p>
        <h2> Instructions I got to know a new ISA which is more based on instructons than register</h2>
        <h3> 6 bits: Address </h3>
        <p>
            Two register and the load vs store bit and byte/word bit.
            For store and both registers the same => makes no sense.
            Those isntructions are redefined as:
            Load Immediate8 into low byte,
            Load HiByte immediate8.
        </p>

        <h3> 6 bits Two register format </h3>
        <p>
            Source can be constant: 1bit. 4 bits for registers. One bit to choose between ADC and XOR.
            AND with itself is SHL. XOR with itself is clear (but maybe redefined () I want to keep my decoding simple).
        <p>
            Constants: sign, exponent: +2 +1 -1 -2
            XOR with -1 is NNOT.  The other three values are defined as these instructions:
            SAR, ROR through carry, ROL through carry ( to keep them close to SHL).
        <h3> 6 bits : Source[] => Target three register format: Logical AND and OR and COPY. </h3>
        <p>       
        if ( source0 &gt; source1 ) AND   -- just think of a matrix with main diagonal .. nothing cyclic <br/>
        if ( source0 &lt; source1 ) OR  <br/>
        else COPY <br/>
        </p><p>COPY onto itself means "swap bytes". </p>

        <h3> 5 bit &lt; : SBC use 2 source registers and then one of them is the target</h3>
        <p> The target is either 111, or 110 meaning indriectly source0 or source1.
            101 means: Discard result == CMP.
            Other values mean: Branch</p>
            <p>
                If both source are the same, target says which one to replace with the immediate value.
                I would rather have 3 bits for the source.
                Jump and Sub combined already use 6 bits, but
                we would still have to encode [const?,const?,target] into 2 bits.
                I cannot go down to three register bacause MUL, DIV, block COPY, SCAN etc. need 4 registers.
            </p>
        <h3> 5 bit &gt; Jump and flags </h3>
        3 bits for the flag: zero, negative, carry, overflow, const 1== interrupt <br/>
        1 bit for the value. <br/>
        1 bit for read (branch) or write.<br/>
        <p> On read the interrupt flag is always 0 for branch always with value=0.
        No jump instead means to store the ProgramPointer is swapped with register.0 (think RCA 1802).
        STI and CLI are delayed by one cycle to allow RTI macro and BRK macro.
        </p>
            Missing atm: atomic RTI, jump absolute should use two registers.
        </p>
        <h1>ALU</h1>
        The ALU receives two operands and prepares everything for the central carry propagation.
        Only two operations on the carry make sense: Identity, inversion. Otherwise we could have already sent the signal.
        So both of these gates read the input, but only one is powererd up by the preparation cirtuit.
        Indentity is implemented as two inversions. When you try to optimize for example for equal lenght signal path,
        you end up at a carry look ahead cirtuit ( bottom up ).
        <h1>Old</h1>
        <h3> Source ( may be a const) => Target two register format </h3>        
        <h4> Some only affect the flags</h4>
        Exclusive OR: XOR, Test (target is really just a source), the constant is sign extended: NOT (do not count, is in constant) <br/>
        Subtract: SUB, SBC, CMP (target is really just a source), NEG ( SUB with commuted operands)

        <h4> Add </h4>
        Add, Adc ( similar to sbc above)
        <p>So 8 variants + the const? flag => 4 bits . And then both registers. Uh. </p>
        <h4> Jump </h4>
        Relative const or absolute register. Condition (the 3 of 6502 and for 16 bit encoding all other combinations also)).
        <p> 4 bit + register does not sound too bad. The 8 bit encoding better uses immediate values </p>
        <h4> Address </h4>
        Address Register and Value Register. Load vs Store. PostIncrement? ( maybe switchable in direction Flag?)
        <p>One could think that RISC does not need too much memory acces, but still we seem to need a quarter of the endoding space.</p>
        <h4> shift </h4>
        Two registers for 16bit encoding, but only one for 8 bit encoding.

        <h1> Register centric version </h1>
        <h2>registers</h2>
        <table>
            <thead>
                <tr>
                    <th>Lo</th><th>Hi</th><th>long</th>
                </tr>
            </thead>
            <tbody>
                <tr><td>P</td><td>P</td><td>Programm counter</td></tr>
                <tr><td>B</td><td>C</td><td>Accumulator { Buffer:Counter } </td></tr>
                <tr><td>X</td><td>X</td><td>IndeX</td></tr>
                <tr><td>Y</td><td>Y</td><td>another Index</td></tr>
                <tr><td>S</td><td>S</td><td>Stack Pointer</td></tr>
                <tr><td>F</td><td></td><td>Status Flags: ZNCVID  (oVerflow)</td></tr>
            </tbody>
        </table>

        <h1>Instruction encoding</h1>
        Instructions with two source registers use each bit to select between two possible source for each input of the ALU.  Default accessible register (general purpose) are BCXY.
        Abbreviations: Immediate. Cnd=Condition. Function "Lambda" L. D is direction, 0: towards GeneralPuroposeReg, towards Flags, towards Registers (first wins)
        <table>
            <thead>
                <tr>
                    <th>OP Code</th><th>Function (SubOp)</th><th>source Register(s)</th><th>Direction</th><th>Target Register</th><th>Immediate</th><th>Explaination</th>
                </tr>
            </thead>
            <tbody>
                <tr><td>1</td><td>LLL&lt;110</td><td>R={B C} R={X Y}</td><td></td><td>TT</td><td></td><td>Register, Register => (Register) Operation. 8:16 bit limitation is motivated by relative addressing</td></tr>
                <tr><td>1110</td><td></td><td>RR</td><td></td><td>LL</td><td></td><td>CMP, BIT , low byte only .. </td></tr>
                <tr><td>1111</td><td></td><td>L</td><td>D</td><td>TT</td><td></td><td>Rotation through carry in Direction, AS</td></tr>
                <tr><td>01</td><td>LL</td><td>R</td><td>D</td><td>T</td><td>0</td><td>Pointer Operation. R={X,Y}, T={B,BC}  </td></tr>
                <tr><td>01</td><td>LL</td><td>R</td><td>D</td><td>T</td><td>1</td><td>Index Operation</td></tr>
                <tr><td>001</td><td></td><td></td><td>RR</td><td>TT</td><td>0</td><td>Copy to register</td></tr>
                <tr><td>001</td><td></td><td></td><td>LL</td><td>TT</td><td>1</td><td>immediate value</td></tr>
                <tr><td>0001</td><td></td><td></td><td>D=1</td><td>FF</td><td>V</td><td>Set Flag FF={CVDI} to Value</td></tr>
                <tr><td>0001</td><td></td><td></td><td>D=0</td><td>FF</td><td>V</td><td>Get Flag aka If FFlag==Voume? Branch!</td></tr>
                <tr><td>0000</td><td></td><td></td><td>D</td><td>PS</td><td>I</td><td>See next table</td></tr>
            </tbody>
        </table>
        <h2> trying to unify S with X and Y</h2>
        <table>
            <thead>
                <tr>
                    <th>OP Code</th><th>Function (SubOp)</th><th>source Register(s)</th><th>Direction</th><th>Function2</th><th>Target Register</th><th>Explaination</th>
                </tr>
            </thead>
            <tbody>
                <tr><td>1</td><td>LLL&lt;110</td><td>R={B C} R={X Y}</td><td></td><td>TT</td><td></td><td>Register, Register => (Register) Operation. 8:16 bit limitation is motivated by relative addressing</td></tr>
                <tr><td>1010     </td><td></td><td></td> <td></td><td>LL=++ -- not neg</td> <td>TT</td><td>Typical in place operations. +=2 and -=2 maybe also</td></tr>
                <tr><td>1000</td><td></td><td></td><td>D</td><td>L</td><td>TT</td><td>Rotation through carry in Direction, Arithmetic Shift</td></tr>

                <tr><td>0111</td><td></td><td>R={B C} R={X Y}</td><td></td><td>LL</td><td></td><td>CMP, BIT , low byte only ... Uh, no 9bit sprite collision for C64? </td></tr>
                <tr style="border-bottom: 2px solid black;">    </tr><td>0110</td><td> </td><td>RR   </td><td></td><td></td><td>TT</td><td>Copy to register (RR==TT?immediate) </td></tr>
                

                
                <tr><td>0101=Immediate   </td> <td></td> <td></td><td></td> <td>LLL</td> <td>T=B,Y</td> <td>L like Opcode 1 & CMP & BIT</td></tr>
                <tr><td>0100=Displacement</td> <td></td><td>R=X,Y</td> <td>D</td><td>8bit|16bit displacement</td> <td>T=B|other index</td><td></td></tr>
                <tr><td>0011=Stream      </td> <td></td><td>R=X,Y</td> <td>D</td><td>++ --</td> <td>T=B|other index</td><td></td></tr>
                <tr><td>0010=Stack       </td> <td></td><td>R=S  </td> <td>D</td><td>++ --</td> <td>TT={B,X,PStatus,PCounter}</td><td> wrong combination of D and ++ --  changes  JSR to BRK and RTS to RTI </td></tr>
                <tr><td>0001=Absolute    </td> <td></td> <td>8bit|16bit address</td>  <td>D</td><td></td><td>TT = B C X </td></tr>
                <tr><td>0001=Absolute    </td> <td></td><td>8bit|16bit address</td><td>Indirect? Swap Y and PC?</td><td></td> <td>TT = PC</td><td>JMP ... indirect is 6502.  Swap Y and PC is the MIPS way</td></tr>
                
                <tr style="border-top: 2px solid black;"><td>0000</td><td></td><td></td><td>D=1</td><td>FF</td><td>V</td><td>Set Flag FF={CVDI} to Value</td></tr>
                <tr><td>0000</td><td></td><td></td><td>D=0</td><td>FF</td><td>V</td><td>Get Flag aka If FFlag==Value? Branch!</td></tr>
            </tbody>

        </table>     
        
        <h3>Details about stack based Instructions: Wrong combination of ++ and D is reversed and second function activated</h3>
        <table>
            <thead>
                <tr>
                    <th>Original function</th><th>reversed</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <tr><td>JSR</td><td>BRK</td></tr>
                    <tr><td>RTS</td><td>RTI</td></tr>
                    <tr><td>PHX</td><td>TXS</td></tr>
                    <tr><td>PLX</td><td>TSX</td></tr>                    
                </tr>
            </tbody>
        </table> 

        <h3> trying to unify S with X and Y (old version)</h3>
        <table>
            <thead>
                <tr>
                    <th>OP Code</th><th>Function (SubOp)</th><th>source Register(s)</th><th>Direction</th><th>Target Register</th><th>Immediate</th><th>Explaination</th>
                </tr>
            </thead>
            <tbody>
                <tr><td>1</td><td>LLL&lt;110</td><td>R={B C} R={X Y}</td><td></td><td>TT</td><td></td><td>Register, Register => (Register) Operation. 8:16 bit limitation is motivated by relative addressing</td></tr>
                <tr ><td>1110</td><td></td><td>RR</td><td></td><td>LL</td><td></td><td>CMP, BIT , low byte only .. </td></tr>
                <tr style="border-bottom: 2px solid black;"><td>1111</td><td></td><td>L</td><td>D</td><td>TT</td><td></td><td>Rotation through carry in Direction, AS</td></tr>
                <tr><td>0</td><td>LL=010..100 </td><td>R=X,Y</td><td>D</td><td>T</td><td></td><td>Pointer Operation, reverse stack. R={X,Y}, T={B,BC}. {LL=010 & T=1 ? TSX }  </td></tr>
                <tr><td>0</td><td>LL={101=BRK-RTI,110=JSR-RTS} for progamm counter, LL={R=S instead of Y} for B</td><td>R=Y,S  </td><td>D</td><td>T</td><td></td><td>Pointer Operation. stack , T={B ,Processor status,Program-Counter}  </td></tr>
                <tr><td>0</td><td>LL=111A </td><td>R=X,Y   </td><td>D</td><td>T</td><td></td><td>Index Operation with immediate / Addressing mode {I16, I16+Y8, X16+I8, Y16+I8</td></tr>

                <tr style="border-top: 2px solid black;" ><td>0001</td><td> </td><td>RR   </td><td></td><td>TT</td><td></td><td>Copy to register (RR==TT?immediate) </td></tr>
                <tr><td>0000</td><td></td><td></td><td>D=1</td><td>FF</td><td>V</td><td>Set Flag FF={CVDI} to Value</td></tr>
                <tr><td>0000</td><td></td><td></td><td>D=0</td><td>FF</td><td>V</td><td>Get Flag aka If FFlag==Voume? Branch!</td></tr>
            </tbody>

        </table>      
        Okay, I can see why MIPS did away with the stack. So I could -- like 6502 and MIPS -- have DEX extra and JumpAndLink via register.
        Even with inner loops, immediate is just too nice to not have all reg-reg also with immediate.
        That would mean as many immediate as reg reg because the format is the same ( reg reg as two separate input groups).  
        <h3>Details</h3>
        <table>
            <thead>
                <tr>
                    <th>P involved</th><th>Stack Involved</th><th>Direction (to GP:0)</th><th>Immediate</th><th>Explanation</th>
                </tr>
            </thead>
            <tbody>
                <tr><td>0</td><td>0</td><td>0</td><td>0</td><td>TSX</td></tr>
                <tr><td>0</td><td>0</td><td>1</td><td>0</td><td>TXS</td></tr>
                <tr><td>0</td><td>1</td><td>0</td><td>0</td><td>PLP</td></tr>
                <tr><td>0</td><td>1</td><td>1</td><td>0</td><td>PHP</td></tr>

                <tr><td>1</td><td>0</td><td>0</td><td>0</td><td>NOP (where else?)</td></tr>
                <tr><td>1</td><td>0</td><td>1</td><td>0</td><td>RTS (shifted from below)</td></tr>
                <tr><td>1</td><td>1</td><td>0</td><td>0</td><td>RTI,(Flags are GP, so this is more specific) </td></tr>
                <tr><td>1</td><td>1</td><td>1</td><td>0</td><td>BRK (where else?)</td></tr>

                <tr><td>1</td><td>0</td><td>0</td><td>1</td><td>JMP</td></tr>
                <tr><td>1</td><td>0</td><td>1</td><td>1</td><td></td></tr>
                <tr><td>1</td><td>1</td><td>0</td><td>1</td><td>JSR </td></tr>
                <tr><td>1</td><td>1</td><td>1</td><td>1</td><td></td></tr>

                <tr><td>0</td><td>0</td><td>0</td><td>1</td><td></td></tr>
                <tr><td>0</td><td>0</td><td>1</td><td>1</td><td></td></tr>
                <tr><td>0</td><td>1</td><td>0</td><td>1</td><td>?PHA</td></tr>
                <tr><td>0</td><td>1</td><td>1</td><td>1</td><td>?PLA</td></tr>

            </tbody>
        </table>        
        <h3>8 Register-Register Functions</h3>
        ADC, SBC, SBC with operands swapped, CMP == 111.
        BIT==110, AND, OR, EOR.
        <h3> Pointer </h3>
        <table>
            <thead>
                <tr>
                    <th>LL</th><th>Explanation</th>
                </tr>
            </thead>
            <tbody>
                <tr><td> 00 </td><td> plain </td></tr>
                <tr><td> 01 </td><td> ++/-- only, no actual data access (T is not used, Direction is used )</td></tr>
                <tr><td> 10 </td><td> ++/-- </td></tr>
                <tr><td> 11 </td><td> ++/-- X becomes S for PHA and PLA, while Y Stack becomes reversed for memcopy</td></tr>
            </tbody>
        </table>

        <h3>Index</h3>
        <table>
            <thead>
                <tr>
                    <th>LL</th><th>Addressing mode</th>
                </tr>
            </thead>
            <tbody>
                <tr><td> 00 </td><td> I16 </td></tr>
                <tr><td> 01 </td><td> I16 + RL  ( register Lo byte ) </td></tr>
                <tr><td> 10 </td><td> I16 + RH </td></tr>
                <tr><td> 11 </td><td> I8 + R  ( or better: R + I8)</td></tr>
            </tbody>
        </table>        

        <h3> Copy to register</h3>
        <table>
            <thead>
                <tr>
                    <th>RR==TT</th><th>Function</th>
                </tr>
            </thead>
            <tbody>
                <tr><td> 00=B </td><td> NOT </td></tr>
                <tr><td> 01=C </td><td> DEC </td></tr>
                <tr><td> 10=X </td><td> NOT </td></tr>
                <tr><td> 11=Y </td><td> NEG </td></tr>
            </tbody>
        </table>        

        <h3> Immediate Value</h3>
        <table>
            <thead>
                <tr>
                    <th>LL</th><th>Function</th>
                </tr>
            </thead>
            <tbody>
                <tr><td> 00 </td><td> Load </td></tr>
                <tr><td> 01 </td><td> ADC </td></tr>
                <tr><td> 10 </td><td> AND </td></tr>
                <tr><td> 11 </td><td> BIT for B and CMP for C </td></tr>
            </tbody>
        </table>

        <h3> 8 Branch Conditions from 6502</h3>
        <p style="white-space: pre-wrap;">
        = &lt;&gt;
        &gt;= &lt;
        C NC
        V NV
        </p>

        <h2>not ISA, but µ-Architecture taken from 8510</h2>
        <table>
            <thead>
                <tr>
                    <th>Lo</th><th>Hi</th><th>long</th>
                </tr>
            </thead>
            <tbody>
                <tr><td>A</td><td>A</td><td>Address Register</td></tr>
                <tr><td>DI</td><td></td><td>Data in</td></tr>
                <tr><td>DO</td><td></td><td>Data out with Tristate buffer</td></tr>
                <tr><td>PD</td><td></td><td>Pre-decode register</td></tr>
                <tr><td>I</td><td></td><td>Instruction register</td></tr>
                <tr><td>Q</td><td>Q</td><td>Programm counter WriteBack</td></tr>
                <tr><td>W</td><td>W</td><td>ALU WriteBack</td>
                <tr><td>M</td><td></td><td>Micro-Code instruction counter (per cycle, each cycle has 4 (or 8?) phases)</td></tr>
            </tbody>
        </table>
<p>
        The Lo ALU has to inputs connected to XL, B , P  and YL, C, D, S. It has Carry look ahead. AND, OR, EOR, ROR is implemented per bit with some circuitry just as in 8080.

    The high ALU can only do ++ and -- . It uses inverters on odd and even bits and has a flat carry with alternated inverted bits. Inputs are: S,X,Y,P

</p>
<a href="ISA16.htm">16 bit words</a>
<a href="Layout.htm">16 bit words</a>
    </body>
</html>